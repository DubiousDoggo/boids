XJTFANIMATE ; ; ;2025-08-08 12:20:07;11.6
	GOTO MAIN
	;*********************************************************************
	; PURPOSE:  ANIMATION EDITOR
	; AUTHOR:   JACK FOX
	; REVISIONS:
	;  *JTF 06/25 Created
	;*********************************************************************
	;
	; LOAD OBJECT AND ANIMATION DATA
INITDEFAULT(OBJECTS) ;
	;
	SET OBJECTS=1
	;
	; VERTICES
	SET OBJECTS(1,"V")=8
	SET OBJECTS(1,"V",1)="-1 -1 -1"
	SET OBJECTS(1,"V",1,"C")="0;0;0"
	SET OBJECTS(1,"V",2)="1 -1 -1"
	SET OBJECTS(1,"V",2,"C")="255;0;0"
	SET OBJECTS(1,"V",3)="-1 1 -1"
	SET OBJECTS(1,"V",3,"C")="0;255;0"
	SET OBJECTS(1,"V",4)="1 1 -1"
	SET OBJECTS(1,"V",4,"C")="255;255;0"
	SET OBJECTS(1,"V",5)="-1 -1 1"
	SET OBJECTS(1,"V",5,"C")="0;0;255"
	SET OBJECTS(1,"V",6)="1 -1 1"
	SET OBJECTS(1,"V",6,"C")="255;0;255"
	SET OBJECTS(1,"V",7)="-1 1 1"
	SET OBJECTS(1,"V",7,"C")="0;255;255"
	SET OBJECTS(1,"V",8)="1 1 1"
	SET OBJECTS(1,"V",8,"C")="255;255;255"
	;
	; LINES
	SET OBJECTS(1,"L")=12
	SET OBJECTS(1,"L",1)="1 2"
	SET OBJECTS(1,"L",2)="2 4"
	SET OBJECTS(1,"L",3)="4 3"
	SET OBJECTS(1,"L",4)="3 1"
	SET OBJECTS(1,"L",5)="5 6"
	SET OBJECTS(1,"L",6)="6 8"
	SET OBJECTS(1,"L",7)="8 7"
	SET OBJECTS(1,"L",8)="7 5"
	SET OBJECTS(1,"L",9)="1 5"
	SET OBJECTS(1,"L",10)="2 6"
	SET OBJECTS(1,"L",11)="4 8"
	SET OBJECTS(1,"L",12)="3 7"
	;
	;SET OBJECTS(1,"F")=0         ; CURRENT KEYFRAME
	;SET OBJECTS(1,"T")=0         ; FRAME TIMER
	;SET OBJECTS(1,"P")="0 0 0"   ; POSITION
	;SET OBJECTS(1,"Q")="0 0 1 0" ; TRANSFORMATION QUATERNION
	;
	; ANIMATION DATA
	SET OBJECTS(1,"A")=2  ; NUMBER OF ANIMATION KEYFRAMES
	SET OBJECTS(1,"A",1,"P")="0 0 5" ; KEYFRAME POSITION
	SET OBJECTS(1,"A",1,"Q")=$$AXISANGLE^XJTFQ(0,1,0,0) ; KEYFRAME QUATERNION
	SET OBJECTS(1,"A",1,"T")=10      ; FRAME TIME
	SET OBJECTS(1,"A",2,"P")="1 1 5"
	SET OBJECTS(1,"A",2,"Q")=$$AXISANGLE^XJTFQ(0,1,0,180)
	SET OBJECTS(1,"A",2,"T")=10
	;
	;
	;
	;SET OBJECTS=2
	;;
	;; VERTICES
	;SET OBJECTS(2,"V")=4
	;SET OBJECTS(2,"V",1)="0 0 0"
	;SET OBJECTS(2,"V",1,"C")="255;255;255" ; VERTEX COLORS
	;SET OBJECTS(2,"V",2)="1 0 0"
	;SET OBJECTS(2,"V",2,"C")="255;0;0"
	;SET OBJECTS(2,"V",3)="0 1 0"
	;SET OBJECTS(2,"V",3,"C")="0;255;0"
	;SET OBJECTS(2,"V",4)="0 0 1"
	;SET OBJECTS(2,"V",4,"C")="0;0;255"
	;;
	;SET OBJECTS(2,"L")=3
	;SET OBJECTS(2,"L",1)="1 2"
	;SET OBJECTS(2,"L",2)="1 3"
	;SET OBJECTS(2,"L",3)="1 4"
	;;
	;SET OBJECTS(2,"A")=1  ; NUMBER OF ANIMATION KEYFRAMES
	;SET OBJECTS(2,"A",1,"P")="0 0 5" ; KEYFRAME POSITION
	;SET OBJECTS(2,"A",1,"Q")=$$AXISANGLE^XJTFQ(0,1,0,0) ; KEYFRAME QUATERNION
	;SET OBJECTS(2,"A",1,"T")=1
	;
	QUIT  ;
	;
	;
LOADDATA(NAME,OBJECTS) ;
	MERGE OBJECTS=^XJTFANIMATE(NAME)
	QUIT
	;
LOADSCENE(NAME,OBJECTS) ;
	NEW LIST ;
	WRITE *27,"[3H",*27,"[2K"
LNA WRITE *27,"[2H",*27,"[2K"
	WRITE "SCENE NAME: "
	SET NAME=$$zScrReadLine(.CTL,20,"","",NAME,1)
	QUIT:CTL="UAR"
	IF NAME="?" DO  GOTO LNA
	. IF 'LIST WRITE !,*27,"[2K",?2,"ENTER THE NAME OF A SCENE TO LOAD.",!?2,"ENTER ? AGAIN TO SEE A LIST OF LOADED SCENES." SET LIST=1
	. ELSE  WRITE !,*27,"[2K",?2,"SCENES:" KILL NAME FOR  SET NAME=$ORDER(^XJTFANIMATE(NAME)) QUIT:NAME=""  WRITE !,*27,"[2K",?4,NAME
	QUIT:NAME=""
	IF '$DATA(^XJTFANIMATE(NAME)) WRITE !,"PROGRAM DOES NOT EXIST." GOTO LNA
	MERGE OBJECTS=^XJTFANIMATE(NAME)
	QUIT
	;
SAVEDATA(NAME,OBJECTS) ;
	NEW GLO,OBJ,SUB
	SET GLO=$NAME(^XJTFANIMATE(NAME))
	;
	SET @GLO=OBJECTS
	FOR OBJ=1:1:OBJECTS DO
	. FOR SUB="V","L","A" DO  ; ONLY SAVE STATIC DATA
	. . MERGE @GLO@(OBJ,SUB)=OBJECTS(OBJ,SUB)
	;
	QUIT
	;
	; LINEAR INTERPOLATE FROM X1 TO X2 ACCORDING TO T
LERP(X1,X2,T) QUIT ((1-T)*X1)+((T)*X2)
	; LINEARLY INTERPOLATE A VECTOR
VLERP(V1,V2,T) ;
	NEW PC,RET
	FOR PC=1:1:$L(V1," ") SET $P(RET," ",PC)=$$LERP($P(V1," ",PC),$P(V2," ",PC),T)
	QUIT RET
MAIN ;
	NEW OBJECTS,OBJECT
	NEW VSCALE,HSCALE
	NEW HEIGHT,WIDTH
	NEW VERTEX,V1,V2
	NEW VERTICES,LINE
	NEW X,Y,Z,X1,Y1,Z1,X2,Y2,Z2,C1,C2
	NEW PX,PY,PZ,SCENE
	NEW DEPTHBUFFER,ZCLIP
	NEW FRAME,NEXTFRAME,T
	;
	; EDITOR STATE DATA
	NEW INPUT,CHAR,PAUSE,NEXT,PREV,ADD,SAVE,LOAD
	NEW QUIT,SKIP,SEL,OBJ,UPDATED,OBJP,OBJQ
	NEW PARAMS,I
	SET OBJ=1,SEL=1
	;
	SET HEIGHT=24,WIDTH=80 ; DEFAULT WINDOW SIZE
	DO GETSCREENSIZE^XJTFTERM(.HEIGHT,.WIDTH) ; CHECK FOR RESIZE
	SET VSCALE=15*HEIGHT/24 ; WINDOW SCALE
	SET HSCALE=30*WIDTH/80
	SET ZCLIP=0.01 ; DISTANCE FROM CAMERA TO NEAR CLIP PLANE
	;
	;
	SET SCENE="DEFAULT"
	DO INITDEFAULT(.OBJECTS)
	;
	WRITE *27,"%@",*27,"[?25l",#  ; SET CODEPAGE DEFAULT, DISABLE CURSOR, CLEAR SCREEN
	DO %zecho(0)
	FOR  DO  HANG:'SKIP 0.05 QUIT:QUIT  ; LOOP UNTIL EXIT
	. ;
	. WRITE #
	. KILL DEPTHBUFFER
	. ;
	. FOR OBJECT=1:1:OBJECTS DO
	. . ;
	. . ; ADVANCE THE ANIMATION
	. . IF $S(PAUSE:NEXT!PREV,1:1) DO
	. . . ;
	. . . IF 'PAUSE SET OBJECTS(OBJECT,"T")=OBJECTS(OBJECT,"T")-1 ; COUNT DOWN THE FRAME TIMER
	. . . IF PAUSE,NEXT SET NEXT=0,OBJECTS(OBJECT,"T")=0 ; ADVANCE TO NEXT KEYFRAME
	. . . IF PAUSE,PREV SET PREV=0 DO
	. . . . ; IF MID-FRAME AND PREV PRESSED, JUMP TO START OF FRAME
	. . . . IF OBJECTS(OBJECT,"T")<OBJECTS(OBJECT,"A",OBJECTS(OBJECT,"F"),"T") SET OBJECTS(OBJECT,"T")=OBJECTS(OBJECT,"A",OBJECTS(OBJECT,"F"),"T")
	. . . . ELSE  SET OBJECTS(OBJECT,"F")=OBJECTS(OBJECT,"F")-2,OBJECTS(OBJECT,"T")=0 ; JUMP 2 BACK AND ADVANCE 1 FRAME OTHERWISE
	. . . . IF OBJECTS(OBJECT,"F")<0 SET OBJECTS(OBJECT,"F")=OBJECTS(OBJECT,"A")-1 ; LOOP BACK TO THE END IF NEEDED
	. . . ;
	. . . IF OBJECTS(OBJECT,"T")'>0 DO  ; IF IT HIT ZERO
	. . . . SET OBJECTS(OBJECT,"F")=OBJECTS(OBJECT,"F")+1  ; ADVANCE TO THE NEXT KEYFRAME
	. . . . IF OBJECTS(OBJECT,"F")>OBJECTS(OBJECT,"A") SET OBJECTS(OBJECT,"F")=1 ; LOOP ANIMATION
	. . . . SET OBJECTS(OBJECT,"T")=OBJECTS(OBJECT,"A",OBJECTS(OBJECT,"F"),"T")  ; LOAD THE FRAME TIMER FROM THE KEYFRAME TIME
	. . ;
	. . ;
	. . ; UPDATE POSITION AND ROTATION
	. . SET FRAME=OBJECTS(OBJECT,"F")
	. . SET NEXTFRAME=FRAME+1
	. . IF NEXTFRAME>OBJECTS(OBJECT,"A") SET NEXTFRAME=1
	. . SET T=OBJECTS(OBJECT,"T")/OBJECTS(OBJECT,"A",FRAME,"T")
	. . SET OBJECTS(OBJECT,"P")=$$VLERP(OBJECTS(OBJECT,"A",FRAME,"P"),OBJECTS(OBJECT,"A",NEXTFRAME,"P"),1-T)
	. . SET OBJECTS(OBJECT,"Q")=$$ONLERP^XJTFQ(OBJECTS(OBJECT,"A",FRAME,"Q"),OBJECTS(OBJECT,"A",NEXTFRAME,"Q"),1-T)
	. . ;
	. . ; RENDER THE OBJECT
	. . DO %zzStrSplitDelimList(OBJECTS(OBJECT,"P")," ",.PX,.PY,.PZ)
	. . FOR VERTEX=1:1:OBJECTS(OBJECT,"V") DO  ; TRANSFORM VERTICES
	. . . SET VERTICES(VERTEX)=$$APPLY^XJTFQ(OBJECTS(OBJECT,"V",VERTEX),OBJECTS(OBJECT,"Q"))
	. . FOR LINE=1:1:OBJECTS(OBJECT,"L") DO
	. . . DO %zzStrSplitDelimList(OBJECTS(OBJECT,"L",LINE)," ",.V1,.V2)
	. . . DO %zzStrSplitDelimList(VERTICES(V1)," ",.X1,.Y1,.Z1)
	. . . DO %zzStrSplitDelimList(VERTICES(V2)," ",.X2,.Y2,.Z2)
	. . . SET C1=OBJECTS(OBJECT,"V",V1,"C")
	. . . SET C2=OBJECTS(OBJECT,"V",V2,"C")
	. . . ;
	. . . SET X1=X1+PX,Y1=Y1+PY,Z1=Z1+PZ
	. . . SET X2=X2+PX,Y2=Y2+PY,Z2=Z2+PZ
	. . . IF Z1<=ZCLIP,Z2<=ZCLIP QUIT
	. . . IF Z2<=ZCLIP DO
	. . . . SET X=(X2-X1)
	. . . . SET Y=(Y2-Y1)
	. . . . SET Z=(Z1-ZCLIP)/(Z1-Z2)
	. . . . SET Z2=ZCLIP
	. . . . SET X2=X1+(Z*X)
	. . . . SET Y2=Y1+(Z*Y)
	. . . IF Z1<=ZCLIP DO
	. . . . SET X=(X1-X2)
	. . . . SET Y=(Y1-Y2)
	. . . . SET Z=(Z2-ZCLIP)/(Z2-Z1)
	. . . . SET Z1=ZCLIP
	. . . . SET X1=X2+(Z*X)
	. . . . SET Y1=Y2+(Z*Y)
	. . . SET X1=X1/Z1*HSCALE+(WIDTH\2),Y1=Y1/Z1*VSCALE+(HEIGHT\2)
	. . . SET X2=X2/Z2*HSCALE+(WIDTH\2),Y2=Y2/Z2*VSCALE+(HEIGHT\2)
	. . . DO DRAWLINE^XJTFANIMATIONS(X1,Y1,X2,Y2,Z1,Z2,.DEPTHBUFFER,WIDTH,HEIGHT,ZCLIP,C1,C2)
	. ;
	. ; HANDLE INPUT AND HUD ELEMENTS
	. KILL INPUT,UPDATED
	. FOR  READ *CHAR:0 QUIT:CHAR=-1  SET INPUT=INPUT+1,INPUT(INPUT)=CHAR,INPUT(INPUT,"KEY")=$KEY ; READ INPUT BUFFER 1 CHAR AT A TIME
	. ;
	. DO HOTKEYBAR(1,$NAME(QUIT)_";"_$NAME(SAVE)_";"_$NAME(LOAD)_";"_$NAME(PAUSE)_$S(PAUSE:";"_$NAME(PREV)_"^[PREV KF;"_$NAME(NEXT)_"^]NEXT KF;"_$NAME(ADD)_"^ADD KF",1:""),.INPUT)
	. ;
	. DO STATUSBAR(HEIGHT-2,$NAME(OBJECTS(OBJ,"F"))_"^KEYFRAME^1;"_$NAME(OBJECTS(OBJ,"T"))_"^TIME^15;")
	. ;
	. SET OBJP=$NAME(OBJECTS(OBJ,"A",OBJECTS(OBJ,"F"),"P"))
	. SET OBJQ=$NAME(OBJECTS(OBJ,"A",OBJECTS(OBJ,"F"),"Q"))
	. SET PARAMS=$NAME(OBJ)_"^^1^1^1^"_OBJECTS_$S(PAUSE:";"_$NAME(OBJECTS(OBJ,"A",OBJECTS(OBJ,"F"),"T"))_"^FRAMETIME^8^1^1;"_OBJP_"$1^X^25^1;"_OBJP_"$2^Y^30^1;"_OBJP_"$3^Z^35^1",1:"")
	. DO PARAMSBAR(2,PARAMS,.SEL,.INPUT,.UPDATED)
	. ;
	. IF PAUSE DO
	. . WRITE *27,"[",3,"H","ROTATE CURRENT KEYFRAME: H/K - YAW  U/J - PITCH  Y/I - ROLL"
	. . FOR I=1:1:INPUT SET CHAR=INPUT(I) DO  ; HANDLE INPUT
	. . . IF CHAR>96 SET CHAR=CHAR-32 ; CONVERT TO UPPERCASE
	. . . SET CHAR=$CHAR(CHAR)
	. . . IF CHAR="H" SET @OBJQ=$$COMP^XJTFQ($$AXISANGLE^XJTFQ(0,1,0,+1),@OBJQ)
	. . . IF CHAR="K" SET @OBJQ=$$COMP^XJTFQ($$AXISANGLE^XJTFQ(0,1,0,-1),@OBJQ)
	. . . IF CHAR="U" SET @OBJQ=$$COMP^XJTFQ($$AXISANGLE^XJTFQ(1,0,0,-1),@OBJQ)
	. . . IF CHAR="J" SET @OBJQ=$$COMP^XJTFQ($$AXISANGLE^XJTFQ(1,0,0,+1),@OBJQ)
	. . . IF CHAR="Y" SET @OBJQ=$$COMP^XJTFQ($$AXISANGLE^XJTFQ(0,0,1,-1),@OBJQ)
	. . . IF CHAR="I" SET @OBJQ=$$COMP^XJTFQ($$AXISANGLE^XJTFQ(0,0,1,+1),@OBJQ)
	. . . ;
	. ;
	. ;
	. IF UPDATED("FRAMETIME") SET OBJECTS(OBJ,"T")=OBJECTS(OBJ,"A",OBJECTS(OBJ,"F"),"T") ;
	. ;
	. ;
	. IF SAVE DO
	. . DO %zecho(1)
	. . WRITE *27,"[3H",*27,"[2K"
	. . WRITE *27,"[2H",*27,"[2K"
	. . SET SCENE=$$zScrPromptAndReadLine(.CTL,20,"SCENE NAME: ","","","",SCENE,1)
	. . DO %zecho(0) ;
	. . IF CTL="UAR" QUIT
	. . DO SAVEDATA(SCENE,.OBJECTS)
	. . SET SAVE=0
	. ;
	. IF LOAD DO
	. . DO %zecho(1)
	. . DO LOADSCENE(.SCENE,.OBJECTS)
	. . DO %zecho(0)
	. . SET LOAD=0
	. ;
	. IF ADD DO  ; ADD NEW KEYFRAME
	. . SET ADD=0
	. . SET OBJECTS(OBJ,"A")=OBJECTS(OBJ,"A")+1
	. . SET OBJECTS(OBJ,"A",OBJECTS(OBJ,"A"),"P")="0 0 5" ; KEYFRAME POSITION
	. . SET OBJECTS(OBJ,"A",OBJECTS(OBJ,"A"),"Q")=$$AXISANGLE^XJTFQ(0,1,0,0) ; KEYFRAME QUATERNION
	. . SET OBJECTS(OBJ,"A",OBJECTS(OBJ,"A"),"T")=1 ; FRAMETIME
	. . SET OBJECTS(OBJ,"F")=OBJECTS(OBJ,"A")-1,OBJECTS(OBJ,"T")=0,NEXT=1 ; SELECT THE FRAME
	;
	;
	;
	WRITE *27,"%@",*27,"[0m",*27,"[?25h" ; RESET TO DEFAULT CODEPAGE AND COLORS, ENABLE CURSOR
	DO %zecho(1)
	QUIT
	;
	;
	; DESCRIPTION: DISPLAY STATIC PARAMETER BAR
	; PARAMETERS:
	;   LINE   (I,REQ) - WHAT LINE OF THE SCREEN SHOULD THE PARAMETER BAR SHOULD BE DISPLAYED ON
	;   PARAMS (I,REQ) - A ; DELIMITED STRING OF ^ DELIMITED PARAMETER PROPERTY STRINGS. SEE PARSEPARAM FOR DETAILS
STATUSBAR(LINE,PARAMS) ;
	NEW COLUMN,PARAM,NAME,INDEX
	WRITE *27,"[",LINE,"H" ; MOVE TO START OF LINE
	WRITE *27,"[0m" ; RESET ATTRIBUTES
	WRITE *27,"[2K" ; CLEAR LINE
	FOR INDEX=1:1:$LENGTH(PARAMS,";") DO
	. DO PARSEPARAM(PARAMS,INDEX,.PARAM,.NAME,.COLUMN) QUIT:PARAM=""
	. WRITE *27,"[",COLUMN,"G" ; MOVE TO COLUMN
	. WRITE $S(NAME'="":NAME,1:PARAM),"=",@PARAM
	. WRITE *27,"[0m"
	QUIT
	; DESCRIPTION: DISPLAY EDITABLE PARAMETER BAR
	; PARAMETERS:
	;   LINE     (I, REQ) - WHAT LINE OF THE SCREEN SHOULD THE PARAMETER BAR SHOULD BE DISPLAYED ON
	;   PARAMS   (I, REQ) - A ; DELIMITED STRING OF ^ DELIMITED PARAMETER PROPERTY STRINGS. SEE PARSEPARAM FOR DETAILS.
	;                       PARAM^NAME^COLUMN^INCREMENT^MIN^MAX^LINE
	;   SELECTED (IO,REQ) - INDEX OF CURRENTLY SELECTED PARAMETER, UPDATED VIA USER INPUT
	;   INPUT    (I, REQ) - BUFFER OF KEYBOARD INPUT THIS FRAME
	;   UPDATED  (O, OPT) - AN INDEX OF PARAMETERS THAT WERE UPDATED VIA USER INPUT
PARAMSBAR(LINE,PARAMS,SELECTED,INPUT,UPDATED) ;
	NEW INDEX,PARAM,CHAR,KEY,COLUMN,INCREMENT,MIN,MAX,NAME,PLINE,I,PP
	; WRAP SELECTION
	IF SELECTED>$LENGTH(PARAMS,";") SET SELECTED=$LENGTH(PARAMS,";")
	;
	; HANDLE SELECTING/EDITING PARAMS WITH ARROW KEYS
	FOR I=1:1:INPUT SET CHAR=INPUT(I),KEY=INPUT(I,"KEY") DO
	. IF $CHAR(CHAR)="?" DO    ; DISPLAY HELP
	. . WRITE *27,"[1H"
	. . WRITE !,"         == CONTROLS ==         "
	. . WRITE !,"LEFT / RIGHT - SELECT PARAMETER "
	. . WRITE !,"   UP / DOWN - EDIT PARAMETER   "
	. . WRITE !,"           Q - QUIT             "
	. . WRITE !,"           ? - HELP             "
	. . READ !,"  (PRESS ANY KEY TO CONTINUE)   ",*%
	. . SET UPDATED=1
	. IF KEY=$$yLFARW() SET:SELECTED>1 SELECTED=SELECTED-1 QUIT
	. IF KEY=$$yRTARW() SET:SELECTED<$LENGTH(PARAMS,";") SELECTED=SELECTED+1 QUIT
	. DO PARSEPARAM(PARAMS,SELECTED,.PARAM,.NAME,.COLUMN,.INCREMENT,.MIN,.MAX)
	. IF PARAM="" QUIT
	. IF NAME="" SET NAME=PARAM
	. DO %zzStrSplitDelimList(PARAM,"$",.PARAM,.PP) IF PP="" SET PP=1
	. IF KEY=$$yUPARW() SET:(+INCREMENT'=0)&((MAX="")!($P(@PARAM," ",PP)+INCREMENT<=MAX)) $P(@PARAM," ",PP)=$P(@PARAM," ",PP)+INCREMENT,UPDATED(NAME)=1 QUIT
	. IF KEY=$$yDNARW() SET:(+INCREMENT'=0)&((MIN="")!($P(@PARAM," ",PP)-INCREMENT>=MIN)) $P(@PARAM," ",PP)=$P(@PARAM," ",PP)-INCREMENT,UPDATED(NAME)=1 QUIT
	;
	; PRINT PARAMETERS
	WRITE *27,"[",LINE,"H" ; MOVE TO START OF LINE
	WRITE *27,"[0m" ; RESET ATTRIBUTES
	WRITE *27,"[2K" ; CLEAR LINE
	FOR INDEX=1:1:$LENGTH(PARAMS,";") DO
	. DO PARSEPARAM(PARAMS,INDEX,.PARAM,.NAME,.COLUMN,"","","",.PLINE) QUIT:PARAM=""
	. DO %zzStrSplitDelimList(PARAM,"$",.PARAM,.PP) IF PP="" SET PP=1
	. WRITE *27,"[",LINE+PLINE,";",COLUMN,"H"    ; MOVE TO ROW, COLUMN
	. IF INDEX=SELECTED WRITE *27,"[7m"          ; HIGHLIGHT SELECTED
	. WRITE $S(NAME'="":NAME,1:PARAM),"=",$P(@PARAM," ",PP) ; WRITE THE PARAM AND VALUE
	. WRITE *27,"[0m"
	;
	QUIT
HOTKEYBAR(LINE,PARAMS,INPUT) ;
	NEW I,CHAR,KEY,INDEX,PARAM,NAME,COLUMN,PLINE,PIX
	;
	FOR INDEX=1:1:$LENGTH(PARAMS,";") DO  ; INDEX PARAMETERS
	. DO PARSEPARAM(PARAMS,INDEX,.PARAM,.NAME) QUIT:PARAM=""
	. SET PIX($A($E($S(NAME'="":NAME,1:PARAM),1)))=PARAM
	;
	FOR I=1:1:INPUT SET CHAR=INPUT(I) DO  ; HANDLE INPUT
	. IF CHAR>96 SET CHAR=CHAR-32 ; CONVERT TO UPPERCASE
	. SET PARAM=PIX(CHAR) QUIT:PARAM=""
	. SET @PARAM='@PARAM ; TOGGLE PARAM ON KEYPRESS
	;
	; PRINT PARAMETERS
	WRITE *27,"[",LINE,"H" ; MOVE TO START OF LINE
	WRITE *27,"[0m" ; RESET ATTRIBUTES
	WRITE *27,"[2K" ; CLEAR LINE
	FOR INDEX=1:1:$LENGTH(PARAMS,";") DO
	. DO PARSEPARAM(PARAMS,INDEX,.PARAM,.NAME,.COLUMN,"","","",.PLINE) QUIT:PARAM=""
	. IF COLUMN'="" WRITE *27,"[",LINE+PLINE,";",COLUMN,"H" ; MOVE TO ROW, COLUMN, IF SPECIFIED
	. IF @PARAM WRITE *27,"[7m" ; HIGHLIGHT IF TOGGLED
	. IF NAME="" SET NAME=PARAM
	. WRITE *27,"[4m",$E(NAME,1),*27,"[24m",$E(NAME,2,$L(NAME)) ; WRITE THE PARAM WITH FIRST CHARACTER UNDERLINED
	. WRITE *27,"[0m "
	. ;
	QUIT
	;
	;
	; DESCRIPTION: PARSE A PARAMETER PROPERTY STRING OUT INTO ITS PARTS
	; PARAMETERS:
	;   PARAMS    (I,REQ) - A ; DELIMITED LIST OF ^ DELIMITED PARAMETER PROPERTY STRINGS
	;   INDEX     (I,REQ) - THE INDEX OF THE PARAMETER TO PARSE
	;   PARAM     (O,REQ) - THE NAME OF THE VARIABLE THAT THE PARAMETER IS BOUND TO, $N FOR A SPECIFIC PIECE
	;   NAME      (O,OPT) - THE NAME THAT SHOULD BE SHOWN FOR THE PARAMETER, IF DIFFERENT THAN THE BOUND VARIABLE NAME
	;   COLUMN    (O,REQ) - THE COLUMN ON THE PARAMETER BAR THE PARAMETER SHOULD BE DISPLAYED AT
	;   INCREMENT (O,OPT) - THE AMOUNT THAT THE BOUND VARIABLE SHOULD BE INCREMENTED OR DECREMENTED BY USING THE UP AND DOWN ARROWS
	;   MIN       (O,OPT) - THE MINIMUM VALUE THE BOUND VARIABLE SHOULD BE ALLOWED TO HAVE
	;   MAX       (O,OPT) - THE MAXIMUM VALUE THE BOUND VARIABLE SHOULD BE ALLOWED TO HAVE
	;   LINE      (O,OPT) - THE LINE THAT THE PARAMETER SHOULD BE DISPLAYED ON, RELATIVE TO THE FIRST LINE OF THE PARAMETER BAR
PARSEPARAM(PARAMS,INDEX,PARAM,NAME,COLUMN,INCREMENT,MIN,MAX,LINE) ;
	NEW PIECE
	SET PIECE=$PIECE(PARAMS,";",INDEX)
	SET PARAM=$PIECE(PIECE,"^",1)
	SET NAME=$PIECE(PIECE,"^",2)
	SET COLUMN=$PIECE(PIECE,"^",3)
	SET INCREMENT=$PIECE(PIECE,"^",4)
	SET MIN=$PIECE(PIECE,"^",5)
	SET MAX=$PIECE(PIECE,"^",6)
	SET LINE=$PIECE(PIECE,"^",7)
	QUIT
	;
	;
	q  ;;#eor#
	;Routine accessed by User Epic
XJTFQ ; ; ;2025-08-08 10:38:54;11.6
	q
	;*********************************************************************
	; PURPOSE:  Library for Quaternions and graphics
	; AUTHOR:   Jack Fox
	; REVISIONS:
	;  *JTF 06/25 Created
	;*********************************************************************
SIN(DEG) QUIT $$zsin(DEG*$$zpi()/180)
COS(DEG) QUIT $$zcos(DEG*$$zpi()/180)
	;
	;
AXISANGLE(AX,AY,AZ,ANGLE) ; CONSTRUCT ROTATION QUATERNION
	NEW SIN,COS SET SIN=$$SIN(ANGLE/2),COS=$$COS(ANGLE/2)
	DO %zUNITIL(0,.AX,.AY,.AZ)
	QUIT $$zStrBuildDelimList(" ",COS,SIN*AX,SIN*AY,SIN*AZ)
	;
CONJ(QUAT) ; CONJUGATE OF Q = Q*
	NEW QW,QX,QY,QZ
	DO %zzStrSplitDelimList(QUAT," ",.QW,.QX,.QY,.QZ)
	QUIT $$zStrBuildDelimList(" ",QW,-QX,-QY,-QZ)
	;;#localInline#
%zCONJIL(QW,QX,QY,QZ) ;
	SET QX=-QX,QY=-QY,QZ=-QZ
	QUIT
	;;#endLocalInline#
NORMSQ(QUAT) ; NORM SQUARED OF Q = ||Q||^2
	NEW QW,QX,QY,QZ
	DO %zzStrSplitDelimList(QUAT," ",.QW,.QX,.QY,.QZ)
	QUIT $$NORMSQIL(QW,QX,QY,QZ)
	;;#localInline#
NORMSQIL(QW,QX,QY,QZ) ;
	QUIT (QW*QW)+(QX*QX)+(QY*QY)+(QZ*QZ)
	;;#endLocalInline#
	;
	;
NORM(QUAT) ; NORM OF Q = ||Q|| = SQRT(Q Q*)
	QUIT $$sqrt($$NORMSQ(QUAT))
	;;#localInline#
NORMIL(QW,QX,QY,QZ) ;
	QUIT $$sqrt($$NORMSQIL(QW,QX,QY,QZ))
	;;#endLocalInline#
DIV(QUAT,DIV) ; SCALAR QUOTIENT = Q / d
	NEW QW,QX,QY,QZ
	DO %zzStrSplitDelimList(QUAT," ",.QW,.QX,.QY,.QZ)
	QUIT $$zStrBuildDelimList(" ",QW/DIV,QX/DIV,QY/DIV,QZ/DIV)
	;;#localInline#
%zDIVIL(QW,QX,QY,QZ,DIV) ;
	SET QW=QW/DIV,QX=QX/DIV,QY=QY/DIV,QZ=QZ/DIV
	QUIT
	;;#endLocalInline#
MUL(QUAT,MUL) ; SCALAR PROCUCT = m Q
	NEW QW,QX,QY,QZ
	DO %zzStrSplitDelimList(QUAT," ",.QW,.QX,.QY,.QZ)
	QUIT $$zStrBuildDelimList(" ",QW*MUL,QX*MUL,QY*MUL,QZ*MUL)
DOT(Q1,Q2) ; DOT PRODUCT = Q1 . Q2
	NEW PC,TOTAL
	FOR PC=1:1:4 SET TOTAL=TOTAL+($P(Q1," ",PC)*$P(Q2," ",PC))
	QUIT TOTAL
ADD(Q1,Q2) ; SUM = Q1 + Q2
	NEW RESULT
	FOR PC=1:1:4 SET RESULT=$$zStrAddPiece(RESULT," ",$P(Q1," ",PC)+$P(Q2," ",PC))
	QUIT RESULT
RECIP(QUAT) ; RECIPROCAL (MULTIPLICATIVE INVERSE) Q^-1 = Q* / ||Q||^2
	QUIT $$DIV($$CONJ(QUAT),$$NORMSQ(QUAT))
	;
UNIT(QUAT) ; UNIT (VERSOR) UQ = Q / ||Q||
	QUIT $$DIV(QUAT,$$NORM(QUAT))
	;;#localInline#
%zUNITIL(QW,QX,QY,QZ) ;
	SET %1=$$NORMIL(QW,QX,QY,QZ)
	DO %zDIVIL(.QW,.QX,.QY,.QZ,%1)
	QUIT
	;;#endLocalInline#
	;
LERP(QL,QR,L,R) ; LINERALY INTERPOLATE BETWEEN QUATERNIONS
	QUIT $$ADD($$MUL(QL,L),$$MUL(QR,R))
	;
COMP(QA,QB) ; COMPOSITION = QA QB
	NEW AW,AX,AY,AZ
	NEW BW,BX,BY,BZ
	NEW QW,QX,QY,QZ
	DO %zzStrSplitDelimList(QA," ",.AW,.AX,.AY,.AZ)
	DO %zzStrSplitDelimList(QB," ",.BW,.BX,.BY,.BZ)
	SET QW=(AW*BW)-(AX*BX)-(AY*BY)-(AZ*BZ)
	SET QX=(AW*BX)+(AX*BW)+(AY*BZ)-(AZ*BY)
	SET QY=(AW*BY)-(AX*BZ)+(AY*BW)+(AZ*BX)
	SET QZ=(AW*BZ)+(AX*BY)-(AY*BX)+(AZ*BW)
	QUIT $$zStrBuildDelimList(" ",QW,QX,QY,QZ)
	;
APPLY(VEC,QUAT) ; APPLY QUAT TO VEC V' = Q V Q^-1
	SET VEC="0 "_VEC ; CAST VECTOR TO QUATERNION
	SET VEC=$$COMP($$COMP(QUAT,VEC),$$RECIP(QUAT)) ; APPLY THE QUATERNION SANDWICH
	SET VEC=$P(VEC," ",2,4) ; CAST BACK TO VECTOR
	QUIT VEC
	;
	; SPHERICAL LINEAR INTERPOLATION
SLERP(QA,QB,T) ; TODO
	QUIT
	; FAST SLERP APPROXIMATION
	; TAKEN FROM https://zeux.io/2016/05/05/optimizing-slerp/
ONLERP(QL,QR,T) ;
	SET CA=$$DOT(QL,QR) ;
	SET D=$$abs(CA) ;
	SET A=1.0904+(D*(-3.2452+(D*(3.55645-(D*1.43519)))))
	SET B=0.848013+(D*(-1.06021+(D*0.215638)))
	SET K=A*(T-0.5)*(T-0.5)+B
	SET OT=T+(T*(T-0.5)*(T-1)*K)
	QUIT $$UNIT($$LERP(QL,QR,1-OT,$S(CA>0:OT,1:-OT))) ;
	;
	;
APPLYFAST(VEC,QUAT) ; APPLY QUAT TO VEC, ASSUMING QUAT IS NORMALIZED
	;
	; INLINE VERSION OF $$COMP($$COMP(QUAT,VEC),$$CONJ(QUAT))
	;
	NEW QW,QX,QY,QZ
	NEW AW,AX,AY,AZ
	NEW BX,BY,BZ
	NEW CW,CX,CY,CZ
	;
	; A = DECOMP(QUAT)
	DO %zzStrSplitDelimList(QUAT," ",.AW,.AX,.AY,.AZ)
	; B = DECOMP(VEC)
	DO %zzStrSplitDelimList(VEC," ",.BX,.BY,.BZ)
	;
	; C = COMP(A,B)
	SET CW=-(AX*BX)-(AY*BY)-(AZ*BZ)
	SET CX=+(AW*BX)+(AY*BZ)-(AZ*BY)
	SET CY=+(AW*BY)-(AX*BZ)+(AZ*BX)
	SET CZ=+(AW*BZ)+(AX*BY)-(AY*BX)
	;
	; Q = COMP(C,CONJ(A))
	SET QW=+(CW*AW)+(CX*AX)+(CY*AY)+(CZ*AZ)
	SET QX=-(CW*AX)+(CX*AW)-(CY*AZ)+(CZ*AY)
	SET QY=-(CW*AY)+(CX*AZ)+(CY*AW)-(CZ*AX)
	SET QZ=-(CW*AZ)-(CX*AY)+(CY*AX)+(CZ*AW)
	;
	QUIT $$zStrBuildDelimList(" ",QW,QX,QY,QZ)
	;
	;
	; TODO: convert to rotation matrix ?
	;
	;
	


